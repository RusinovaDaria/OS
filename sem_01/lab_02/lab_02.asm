; Задание: 
; Программа начинает работать в реальном режиме. Для перевода в защищенный режим выполняются необходимые действия. 
; В защищенном режиме программа работает на нулевом уровне привилегий.
; В защищенном режиме программа должна: 
; 1 - определить объем доступной физической памяти; 
; 2 - осуществить ввод с клавиатуры строки с выводом введенной строки на экран;
; 3 - получить информацию на экране от системного таймера или в виде мигающего курсора, 
;           или в виде количества тиков с момента запуска программы на выполнение, 
;           или в виде значения реального времени.
; Затем программа корректно возвращается в реальный режим с соответствующими сообщениями.
;--------------------------------------------------------------------------------------------------------------------

; * В защищенном режиме определить объем доступной физической памяти следующим образом – первый мегабайт пропустить; 
        ; начиная со второго мегабайта сохранить байт или слово памяти, записать в этот байт или слово сигнатуру, 
        ; прочитать сигнатуру и сравнить с сигнатурой в программе, если сигнатуры совпали, то это – память. 
        ; Вывести на экран полученной количество байтов доступной памяти.

.386p

include macro.inc

; СТРУКТУРА ДЕСКРИПТОРА СЕГМЕНТА В ТАБЛИЦЕ ГЛОБАЛЬНЫХ ДЕСКРИПТОРОВ GDT
seg_descr struc    
    lim 	dw 0	; размер 
    base_l 	dw 0	; младшие 16 битов базового линейного адреса
    base_m 	db 0	; следующие 8 битов базового линейного адреса
    attr_1	db 0	; атрибуты
    attr_2	db 0	; атрибуты
    base_h 	db 0	; старшие 16 битов базового линейного адреса
seg_descr ends

; справка: рудаков-финогенов, стр 286 
load_to_gdt macro desc
    shl eax, 4                    ; eax - линейный базовый адрес 
    mov word ptr desc.base_l, ax  ; загрузка младшей часть базы
    shr eax, 16                   ; старшую половину eax в ax
    mov byte ptr desc.base_m, al  ; загрузка средней часть базы
    mov byte ptr desc.base_h, ah  ; загрузка старшей часть базы
endm

; загрузить переменную с размером и адресом GDT в регистр GDTR
load_gdtr macro reg                 ; в reg полный линейный адрес GDT
    mov	dword ptr gdtr + 2, reg	    ; кладём полный линейный адрес в старшие 4 байта переменной gdtr
    mov word ptr  gdtr, gdt_size-1	; в младшие 2 байта заносим размер gdt, из-за определения gdt_size (через $) настоящий размер на 1 байт меньше
    lgdt fword ptr gdtr 		    ; загрузим GDT
endm

int_descr struc 
    offs_l 	dw 0  ; Младшие 16 битов адреса, куда происходит переход в случае возникновения прерывания.
    sel		dw 0  ; Селектор сегмента с кодом прерывания/Переключатель сегмента ядра
    cntr    db 0  ; Счётчик, не используется в данной программе. 
    attr	db 0  ; Атрибуты
    offs_h 	dw 0  ; Старшие 16 битов адреса, куда происходит переход.
int_descr ends

; справка: рудаков-финогенов, стр 286 
load_to_idt macro desc
    mov	desc.offs_l, ax     ; загрузить младшую часть смещения
    shr	eax, 16             ; переместить старшую часть в младшую
    mov	desc.offs_h, ax     ; загрузить старшую часть смещения
endm

; написать в команду шестнадцатиричном коде
far_jump macro label, segment
    db	0EAh 
    dd	offset label
    dw	segment
endm

; сегмент стека
stack_seg segment  para stack 'STACK'
    stack_start	db	100h dup(?)
    stack_size = $-stack_start
stack_seg 	ENDS

; сегмент данных 
data_seg segment para 'DATA'

    ;        < ГЛОБАЛЬНАЯ ТАБЛИЦА ДЕСКРИПТОРОВ СЕГМЕНТОВ >
    ;------------------------------------------------------------

    ; обязательный нулевой дескриптор 
    gdt_null  seg_descr <0, 0, 0, 0, 0, 0>
    
    ; 16-битный сегмент кода - для реального режима
    gdt_CS_16bit seg_descr <rm_code_size-1, 0, 0, 98h, 00000000b, 0>

    ; 16-битный сегмент данных - для реального режима и для исследования памяти
    gdt_DS_16bit seg_descr <data_size - 1, 0, 0, 92h, 0, 0>  

    ; 32-битный сегмент кода - для защищенного режима
    gdt_CS_32bit seg_descr <pm_code_size-1, 0, 0, 98h, 01000000b, 0>

    ; 32-битный сегмент данных - для защищенного режима
    gdt_DS_32bit seg_descr <data_size - 1, 0, 0, 92h, 11000000b, 0>

    gdt_FLAT_32bit seg_descr <0FFFFh, 0, 0, 92h, 11001111b, 0>

    ; 32-битный сегмент стека - для защищенного режима 
    gdt_SS_32bit seg_descr <stack_size-1, 0, 0, 92h, 01000000b, 0>
        
    ; 32-битный сегмент видеопамяти == сегмент данных видеобуфера
    gdt_VB_32bit seg_descr <3999, 8000h, 0Bh, 92h, 01000000b, 0>

    gdt_size = $-gdt_null ; размер таблицы  GDT 
    gdtr	df 0	      ; тут будет храниться базовый линейный адрес и размер таблицы GDT

    ; селекторы дескрипторов сегментов в таблице GDT
    sel_CS_16bit    equ    8   
    sel_DS_16bit    equ   16   
    sel_CS_32bit    equ   24
    sel_DS_32bit    equ   32
    sel_SS_32bit    equ   40
    sel_VB_32bit    equ   48
    
    ;------------------------------------------------------------


    ;        < ТАБЛИЦА ДЕСКРИПТОРОВ ПРЕРЫВАНИЙ >
    ;------------------------------------------------------------
    
    IDT	label byte

    ; первые 32 дескриптора - исключения, в программе не используются
    waste_12 int_descr 12 dup (<0, sel_CS_32bit, 0, 10001111b, 0>) 
    trap_13 int_descr <0, sel_CS_32bit, 0, 10001111b, 0>
    waste_19 int_descr 19 dup (<0, sel_CS_32bit, 0, 10001111b, 0>) 

    ; дескриптор прерывания от таймера
    int08 int_descr <0, sel_CS_32bit, 0, 10001110b, 0> 

    ; дескриптор прерывания от клавиатуры
    int09 int_descr	<0, sel_CS_32bit, 0, 10001110b, 0> 

    idt_size = $-waste_12 ; размер таблицы IDT

    idtr df 0              ; будет хранить базовый линейный адрес (4 байта) таблицы IDT и ее размер (2 байта)
    idtr_backup df	0      ; чтобы запомнить предыдущее значение и восстановить его при переходе обратно в реальный режим

    mask_master	db 0		; маска прерывания ведущего контроллера
    mask_slave	db 0		; маска прерывания ведомого контроллера
    
    ;------------------------------------------------------------
    
    ;  < Символьные и строковые данные, служебные переменные >
    ;------------------------------------------------------------

	; Номер скан кода (с клавиатры) символа ASCII == номеру соответствующего элемента в таблице:
	ascii	db 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 45, 61, 0, 0
			db 81, 87, 69, 82, 84, 89, 85, 73, 79, 80, 91, 93, 0, 0, 65, 83
			db 68, 70, 71, 72, 74, 75, 76, 59, 39, 96, 0, 92, 90, 88, 67
			db 86, 66, 78, 77, 44, 46, 47

    ; -------------< счетчики и флаги >---------------
    enter_pressed	    db 0				 
    ticks_counter	    dd 0		    ; счетчик тиков таймера
    symbol_position     dd 1160         ; Позиция выводимого символа

    ; -----------------< сообщения >------------------
    msg_rm_1   db 'Initially in Real Mode. $'
    msg_pm db 'To enter Protected Mode press any key!$'
    msg_rm_2  db 'Returned to Real Mode again!$'

    data_size = $-gdt_null ; размер сегмента данных
data_seg ends

PM_code_seg segment para public 'CODE' use32

    assume cs:PM_code_seg, ds:data_seg

    pm_entry:

        ; ЗАГРУЖАЕМ В СЕГМЕНТНЫЕ РЕГИСТРЫ СЕЛЕКТОРЫ СЕГМЕНТОВ

        mov	ax, sel_DS_32bit 
        mov	ds, ax

        mov	ax, sel_VB_32bit
        mov	es, ax

        mov	ax, sel_SS_32bit
        mov	ss, ax

        mov	eax, stack_size
        mov	esp, eax

        ; разрешить прерывания, которые 
        ; мы запрещали в реальном режиме
        sti 

        ; вывод строк - сохранение символов в видеопамять
        return_string
        invite_string
        memory_string

        ; подсчет и вывод объема доступной памяти
        call countAvailableMemory

        ; Возвращение в реальный режим происходит по нажатию
        ; клавиши 'enter' - это будет обработано в коде обработчика прервания 
        ; чтобы программа не завершалась до этого момента, нужен бескончный цикл
    instance:
        test enter_pressed, 1
        jz	instance

        ; запрещаем прерывания
        ; немаскируемые уже запрещены
        cli ; сброс флага прерывания IF = 0
        far_jump return_rm, sel_CS_16bit    

        countAvailableMemory proc uses ds eax ebx
            
            mov ax, sel_DS_32bit
            mov ds, ax
            
            mov ebx, 100001h ; пропустить первый мегабайт
            mov dl, 10101010b 
            mov	ecx, 0FFEFFFFEh

            iterate_through_memory:
                mov dh, ds:[ebx] ; сохраняем байт памяти

                mov ds:[ebx], dl        ; пишем в память
                cmp ds:[ebx], dl        ; проверяем - если записано то, что мы пытались записать
                                                ; то это доступная память
                jnz print_memory_counter        ; иначе мы дошли до конца паямти - надо вывести
            
                mov	ds:[ebx], dh ; восстановить байт памяти
                inc ebx          ; если удалось записать - увеличиваем счетчик памяти 
            loop iterate_through_memory

            print_memory_counter:
                mov eax, ebx 
                xor edx, edx

                mov ebx, 100000h
                div ebx

                mov ebx, 46
                call print_eax

                mov ebx, 64
                mov al, 'h'
                mov es:[ebx], al

                mov ebx, 68
                mov al, 'M'
                mov es:[ebx], al

                mov ebx, 70
                mov al, 'b'
                mov es:[ebx], al
            ret
        countAvailableMemory endp

        ;-----------------< PRINTING USTILS >---------------------

        print_eax proc uses ecx ebx edx     
                add ebx, 10h 
                mov ecx, 8   
            
            print_symbol: 
                mov dl, al
                and dl, 0Fh      
                
                cmp dl, 10
                jl add_zero_sym
                add dl, 'A' - '0' - 10 

            add_zero_sym:
                add dl, '0'
                
                mov es:[ebx], dl ; записать в видеобуффер
                ror eax, 4       ; циклически сдвинуть вправо (FEDC) -> (CFED) -> (DCFE) -> (EDCF) -> (FEDC)
                sub ebx, 2       ; печатаем след символ
                loop print_symbol
            ret
        print_eax endp

        print_dl proc uses eax ebx ecx edx
            mov al, dl
            xor ecx, ecx

            add ebx, 4
            mov cl, 2

            mov dl, 10
            print_al:
                xor ah, ah
                div dl
                add ah, '0'
                mov es:[ebx], ah 
                sub ebx, 2
                loop print_al
            ret
        print_dl endp

        ; справка: рудаков "вывод реального времени"
        print_time proc uses eax ebx ecx edx 

            mov ecx, 65536
            xor edx, edx
            mul ecx
            mov ecx, 1193180
            div ecx 
            
            xor edx, edx
            mov ecx, 60
            div ecx
            
            mov ebx, 154
            call print_dl

            mov dh, ':'
            mov es:[ebx], dh
            sub ebx, 6
            
            xor edx, edx
            div ecx
            call print_dl

            mov dh, ':'
            mov es:[ebx], dh
            sub ebx, 6
            xor dh, dh
            
            mov dl, al
            call print_dl

            ret
        print_time endp

        ;----------------------------------------------------------


        ;--------< INTERRUPTIONS AND EXCLUSIONS HANDLERS >---------

        int08_handler proc uses eax 

            ; получили текущее количество тиков
            mov  eax, ticks_counter

            ; вывели время
            call print_time

            ; увеличили текущее количество тиков
            inc eax

            ; сохранили 
            mov ticks_counter, eax

            ; отправили EOI ведущему контроллеру прерываний
            mov	al, 20h 
            out	20h, al
            
            iretd
        int08_handler endp

        int09_handler proc uses eax ebx edx 

            ; занести скан-код нажатой клавиши из порта клавиатуры в al
            in	al, 60h    

            ; пришел скан-код enter?
            cmp	al, 1Ch 	
       
            jne	print_value         ; Если не enter - выведем, то что ввели
            or enter_pressed, 1     ; Если enter - устанавливаем флаг возврата

            ; завершить обработку прерывания 
            jmp handle_keyboard
            
            print_value:

                ; Пришел код нажатой клавиши или отжатой?
                cmp al, 80h  

                ; Отжатой - ничего не выводим
                ja handle_keyboard 	 

                ; Нажатой - выведем на экран   
                xor ah, ah	 
                xor ebx, ebx
                mov bx, ax
                
                mov dl, ascii[ebx]         ; ASCII код нажатой клавиши по скан коду из таблицы
                mov ebx, symbol_position   ; текущая позиция вывода символа
                mov es:[ebx], dl

                ; Увеличим текущую позицию вывода
                add ebx, 2          
                mov symbol_position, ebx

            handle_keyboard: 

                ; справка: рудаков стр 122
                ; ----------------------------------------------------

                in	al, 61h ; сообщаем контроллеру о приёме скан кода:

                or	al, 80h ; установкой старшего бита - 1000000
                out	61h, al 
                
                and al, 7Fh ; и последующим его сбросом - 01111111
                out	61h, al

                ; посылаем команду end of Interrupt 
                ; ведущему контроллеру прерываний
                mov	al, 20h 
                out	20h, al

                iretd
        int09_handler endp

        empty_handler proc
            iret
        empty_handler endp

        exc13_handler proc uses eax
            pop eax
            iret
        exc13_handler endp

        ;----------------------------------------------------------

    pm_code_size = $-pm_entry 	
PM_code_seg ends

RM_code_seg segment para public 'CODE' use16
    assume cs:RM_code_seg, ds:data_seg

    rm_entry:

        ; загружаем в сегментный регистр 
        ; линейный адрес сегмента данных, чтобы 
        ; адресоваться в нем 
        mov ax, data_seg
        mov ds, ax

        ; загружаем в сегментный регистр 
        ; линейный адрес сегмента кода для з.р., 
        ; чтобы адресоваться в нем 
        mov ax, PM_code_seg
        mov es, ax

        ; взаимодействие с пользователем - строки,
        ; ожидание ввода символа, очистить экран
        print_str msg_rm_1  
        print_str msg_pm
        wait_key
        clear_screen 

        ;    ЗАГРУЗКА В ДЕСКРИПТОРЫ В ТАБЛИЦЕ GDT ЛИНЕНЫХ 
        ;             БАЗОВЫХ АДРЕСОВ СЕГМЕНТОВ
        ; ---------------------------------------------------
        xor	eax, eax
        mov	ax, RM_code_seg 
        load_to_gdt gdt_CS_16bit

        xor	eax, eax
        mov ax, PM_code_seg
        load_to_gdt gdt_CS_32bit

        xor	eax, eax
        mov ax, data_seg
        load_to_gdt gdt_DS_32bit

        xor	eax, eax
        mov ax, stack_seg
        load_to_gdt gdt_SS_32bit
        ; ---------------------------------------------------


        ; ЗАГРУЗКА В РЕГИСТР GDTR ЛИНЕЙНОГО БАЗОВОГО АДРЕСА И
        ;              РАЗМЕРА ТАБЛИЦЫ GDT
        ; ---------------------------------------------------
        mov ax, data_seg
        shl eax, 4

        add	eax, offset gdt_null 
        mov	dword ptr gdtr + 2, eax	    ; заносим полный линейный адрес в старшие 4 байта переменной gdtr
        mov word ptr  gdtr, gdt_size-1	; в младшие 2 байта заносим размер gdt, из-за определения gdt_size (через $) настоящий размер на 1 байт меньше
        
        ; ПРИВЕЛЕГИРОВАННАЯ КОМАНДА! можем ее использовать в реальном режиме
        ; потому что нет никакой защиты!
        lgdt fword ptr gdtr 		    ; загрузим GDT
        ; ---------------------------------------------------


        ; ЗАПОЛНЕНИЕ ДЕСКРИПТОРОВ ПРЕРЫВАНИЙ ЛИНЕЙНЫМИ 
        ; АДРЕСАМИ ОБРАБОТЧИКОВ ПРЕРЫВАНИЙ 
        ; (базовым линейным адресом и смещением)
        ; ---------------------------------------------------
        
        ; ЗАГЛУШКИ для неиспопльзуемых исключений
        push ecx
        push ebx
        mov ebx, 0
        mov ecx, 12
        load_dummy_12:
            lea eax, es:empty_handler
            load_to_idt waste_12[ebx]
            inc ebx
            loop load_dummy_12
        pop ebx
        pop ecx

        ; ДЛЯ ИСКЛЮЧЕНИЯ GENERAL PROTECTION НУЖЕН ОСОБЕННЫЙ ОБРАБОТЧИК
        lea eax, es:exc13_handler
        load_to_idt trap_13 ; исключение general protection

        push ecx
        push ebx
        mov ebx, 0
        mov ecx, 19
        load_dummy_19:
            lea eax, es:empty_handler
            load_to_idt waste_19[ebx]
            inc ebx
            loop load_dummy_19
        pop ebx
        pop ecx

        ; ЗАПОЛНЕНИЕ ДЕСКРИПТОРОВ ПРЕРЫВАНИЙ ОТ ТАЙМЕРА И КЛАВИАТУРЫ
        ; АДРЕСАМИ НАШИХ ОБРАБОТЧИКОВ
        ;------------------------------------------------------------
        lea eax, es:int08_handler
        load_to_idt int08 ; прерывание таймера

        lea eax, es:int09_handler
        load_to_idt int09 ; прерывание клавиатуры
        ;------------------------------------------------------------

        ; ЗАГРУЗКА В ПЕРЕМННУЮ(! не регистр) IDTR БАЗОВОГО ЛИНЕЙНОГО 
        ; АДРЕСА И РАЗМЕРА НАШЕЙ ТАБЛИЦЫ IDT
        xor eax, eax
        mov ax, data_seg
        shl eax, 4
        add	eax, offset IDT
        
        mov	 dword ptr idtr + 2, eax	; загрузить полный линейный адрес в старшие 4 байта переменной idtr
        mov  word ptr  idtr, idt_size-1	; в младшие 2 байта заносим размер idt
        ;------------------------------------------------------------


        ;     ПЕРЕПРОГРАММИРОВАНИЕ КОНТРОЛЛЕРА ПРЕРЫВАНИЙ - PIC
        ;------------------------------------------------------------
        
        ; * зачем мы вообще перепрограммируем контроллер прерываний: 
        ; ------------------------------------------------------------
        ;   в реальном режиме базовый вектор = 8, системный таймер подключен к IRQ0 мастера 
        ;   вектор прерывания (== номер), который приходит на ножку PIC от системного таймера == 0
        ;   8 + 0 = 8 - восьмое прерывание в таблице
        ;                 ***
        ;   в защищенном режиме первые 32 дескриптора таблицы отведены под исключения 
        ;   восьмое прерывние располагается в нашей таблице сразу за 31м исключением (32 номер)
        ;   на ножку IRQ0 приходит прерывание от системного таймера - чтобы вычислить
        ;   номер дескриптора этого прерывния в таблице, надо прибавить 32
        ;   32 + 0 = 32 -> 32 == новый базовый вектор 
        ; 
        ; ОТВЕТ: Потому что нужно перепрограммировать контроллер прерываний на новый базовый вектор 


        ; 1 - сохраняем маски ведущего и ведомого контроллеров для реального режима
        ;     чтобы потом восстановить по возвращение в реальный режим
        in	al, 21h						
        mov	mask_master, al				
        in	al, 0A1h			
        mov	mask_slave, al

        ; справка: рудаков стр 111
        ; Для смены базового вектора надо выполнить инициализацию контроллера
        ; инициализация состоит из трех "слов" инициализации: СКИ1, СКИ2, СКИ3

        ; СКИ1
        mov	al, 11h						; команда - инициализировать ведущий контроллер
        out	20h, al						; отправить команду по шине данных ведущему контроллеру

        ; СКИ2 : ЗАДАТЬ НОВЫЙ БАЗОВЫЙ ВЕКТОР 
        mov	al, 32						; базовый вектор (начальное смещение для обработчика) установить в 32
        out	21h, al						; отправить базовый вектор ведущему контроллеру

        ; СКИ3 : Присоединить ведомый контроллер ко входу IRQ2
        ; ведущего контроллера
        mov	al, 4						; 4 = 0000 0100
        out	21h, al                     ; сообщить master PIC, что slave подключён к IRQ2
        mov	al, 1						; указываем, что нужно будет посылать
        out	21h, al                     ; команду завершения обработчика прерывания

        ; Запретим (замаскируем) все прерывания в ведущем контроллере, 
        ; кроме IRQ0 (таймер) и IRQ1(клавиатура)
        mov	al, 0FCh ; 11111100, 0 - разрешено, 1 - запрещено
        out	21h, al

        ; запретим (замаскируем) все прерывания в ведомом контроллере
        mov	al, 0FFh ; 11111111
        out	0A1h, al

        ; СОХРАНЯЕМ СТАРОЕ ЗНАЧЕНИЕ IDTR ДЛЯ ВОССТАНОВЛЕНИЯ 
        ; ПОСЛЕ ВЫХОДА ИЗ ЗАЩИЩЕННОГО РЕЖИМА
        sidt fword ptr idtr_backup

        ; загружаем в IDTR адрес и размер нашей таблицы прерываний
        lidt fword ptr idtr             
        
        ; ОТКРЫВАЕМ ЛИНИЮ A20 - чтобы можно было адресоваться по 
        ; памяти за пределами первого мегабайта
        
        ; справка: рудаков стр 304
        ; 60h/64h - порты контроллера интерфейса PS/2
        mov al, 0D1h ; команда управления 
        out 64h, al  ; линией а20
        mov al, 0DFh ; команда открытия
        out 60h, al  ; линии а20 в порт контроллера интерфейса PS/2
        
        ; так тоже можно открыть линию а20,
        ; на современных компьютерах это даже 
        ; предпочтительнее
        ; - у порта 92h есть вентиль А20
        ;in	al, 92h	 ; получить набор флагов	
        ;or	al, 2	 ; установить 2ой бит		
        ;out	92h, al	 ; отправить обратно

        cli         ; отключить маскируемые прерывания
        in	al, 70h ; и немаскируемые прерывания, полуичть EFLAGS
        or	al, 80h ; 10000000 - IF сброс 
        out	70h, al

        ; получить счётчик реального времени bios
        ; - для обработчика прерывания от таймера 
        ; в защищенном режиме
        push ds
        mov	ax, 40h  ; настроить ds на область памяти
        mov	ds, ax   ; BIOS 
        mov eax, dword ptr ds:[6Ch] ; получить счетчик
        pop ds
        mov dword ptr ticks_counter, eax ; сохранить в переменную

        ; УСТАНОВКА PROTECTION ENABLED
        ; ПЕРЕХОД В ЗАЩИЩЕННЫЙ РЕЖИМ
        mov	eax, cr0
        or eax, 1    ; 0-й бит - pe -> 00000001 
        mov	cr0, eax

        ; переходим к коду защищенного режима
        db	66h 
        far_jump pm_entry, sel_CS_32bit


    return_rm:

        ; закрыть линию а20 
        ; справка: рудаков стр 305
        mov al, 0D1h ; команда управления 
        out 64h, al  ; линией а20
        mov al, 0DDh ; команда закрытия
        out 60h, al  ; в порт контроллера интерфейса PS/2
       
        ; ВЕРНУТЬСЯ В РЕАЛЬНЫЙ РЕЖИМ
        mov	eax, cr0
        and	al, 0FEh 	; сбрасываем флаг защищенного режима PE 11111110
        mov	cr0, eax

        ; чтобы занести в теневой регистр 
        db	0EAh	; far jmp RM_code_seg:$+4
        dw	$+4	   
        dw	RM_code_seg

        ; настроить сегментные регистры 
        ; на сегменты реального режима
        mov	eax, data_seg
        mov	ds, ax          
            
        mov eax, PM_code_seg
        mov	es, ax
            
        mov	ax, stack_seg
        mov	ss, ax
            
        mov	ax, stack_size
        mov	sp, ax

        ; СНОВА ПЕРЕПРОГРАММИРОВАТЬ PIC - УЖЕ НА СМЕЩЕНИЕ РЕАЛЬНОГО РЕЖИМА

        mov	al, 11h					; инициализация pic
        out	20h, al

        mov	al, 8					; отправка смещения
        out	21h, al
            
        mov	al, 4					; mask_slave pic подключён к IRQ2
        out	21h, al
            
        mov	al, 1                   ; необходимо отправлять команду завершения обработчика прерывания
        out	21h, al

        ; ВОССТАНОВЛЕНИЕ МАСОК РЕАЛЬНОГО РЕЖИМА
        mov	al, mask_master 
        out	21h, al
        mov	al, mask_slave
        out	0A1h, al

        ; восстанавливаем таблицу дескриптров прерываний 
        ; реального режима
        lidt fword ptr idtr_backup

        in	al, 70h ; разрешить немаскируемые прерывания
        and	al, 7FH
        out	70h, al
        sti     ; и маскируемые

        ; ОЧИСТИТЬ ЭКРАН И ПОПРОЩАТЬСЯ С ПОЛЬЗОВАТЕЛЕМ
        clear_screen
        print_str msg_rm_2
        
        mov	ax, 4C00h
        int	21h

    rm_code_size = $-rm_entry
RM_code_seg	ends
end rm_entry